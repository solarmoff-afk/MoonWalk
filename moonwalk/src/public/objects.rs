// Часть проекта MoonWalk с открытым исходным кодом.
// Лицензия EPL 2.0, подробнее в файле LICENSE. Copyright (c) 2025 MoonWalk

use glam::{Vec2, Vec4};

use crate::objects::ObjectId;
use crate::{MoonWalk, FontAsset, PathBuilder, TextAlign};

impl MoonWalk {
    /// Функция для создания прямоугольника и получения его ID.
    /// Важное предупреждение: НЕ СОЗДАВАЙТЕ ОБЪЕКТЫ КАЖДЫЙ КАДР
    /// ЕСЛИ ЭТО НЕ ВАША ПРЯМАЯ ЦЕЛЬ. После создания объекта он
    /// существует в кэше рендер движка и просто отправляется на
    /// отрисовку в момент вызове render_frame, вам нужно только
    /// создать объект один раз, получить его ID (структура ObjectId)
    /// и работать с ним используя методы конфигурации
    pub fn new_rect(&mut self) -> ObjectId {
        self.renderer.new_rect()
    }

    /// Эта функция создаёт текст. Рендеринг текстов менее производительный чем
    /// рендеринг прямоугольников, но чаще всего текстов и меньше чем прямоугольников
    /// (В играх и UI). Это не должно быть критичным, но нужно учитывать.
    /// В будущем могут быть работы по дополнительной оптимизации
    pub fn new_text(&mut self, content: &str, font: FontAsset, size: f32) -> ObjectId {
        // Конвертируем обратно во внутренний тип
        let internal_id = crate::textware::FontId(font.0);
        self.renderer.state.store.new_text(content.to_string(), internal_id, size)
    }

    /// [WAIT DOC]
    pub fn new_path_builder(&self) -> PathBuilder {
        PathBuilder::new()
    }

    /// [WAIT DOC]
    pub fn parse_svg_path(&self, pb: &mut crate::path::PathBuilder, data: &str) -> Result<(), String> {
        crate::path::svg::parse_svg_path(pb, data)
    }

    // Методы для настройки свойств объектов

    /// Функция для изменения позиции любого объекта по его ID
    /// (Структура ObjectId которую можно получить вызвав new_* функцию)
    /// принимает ID объекта и структуру Vec2 для описания 2D позиции
    /// в мировой системе координат, (0, 0) это верхний левый угол.
    pub fn set_position(&mut self, id: ObjectId, pos: Vec2) {
        self.renderer.config_position(id, pos);
    }

    /// Функция для изменения размер любого объекта по его ID
    /// (Структура ObjectId которую можно получить вызвав new_* функцию)
    /// принимает ID объекта и структуру Vec2 для описания ширины и высоты.
    pub fn set_size(&mut self, id: ObjectId, size: Vec2) {
        self.renderer.config_size(id, size);
    }

    /// Функция для конфигурации угла вращения. Принимает ID объекта
    /// и f32 в качестве угла. ИСПОЛЬЗУЕТ РАДИАНЫ, А НЕ ГРАДУСЫ!
    pub fn set_rotation(&mut self, id: ObjectId, radians: f32) {
        self.renderer.config_rotation(id, radians);
    }

    /// Функция для изменения цвета любого объекта по его ID
    /// принимает ObjectId и Vec4 из GLAM. Цвета заполняются
    /// следующим образом:
    ///     1 значение - Красный, 0-1 (Где 0 это 0, а 1 это 255 по RGBa)
    ///     2 значение - Зелёный, 0-1
    ///     3 значение - Синий  , 0-1
    ///     4 значение - Прозрачность (Альфа канал), тоже от 0 до 1
    ///
    /// Прозрачность 0 это объект не видно, 1 полностью видно,
    /// 0.5 это полупрозрачный
    pub fn set_color(&mut self, id: ObjectId, color: Vec4) {
        self.renderer.config_color(id, color);
    }

    /// Эта функция устаналивает второй цвет который нужен для градиента. Принимает
    /// айди объекта и vec4 (Второй цвет поддерживает прозрачность как и первый)
    /// Второй цвет начнёт работать только когда будет установлен линейный или
    /// радиальный градиент
    pub fn set_color2(&mut self, id: ObjectId, color2: Vec4) {
        self.renderer.config_color2(id, color2);
    }

    /// Эта функция устанавливает объекту объекту линейный градиент. Принимает его 
    /// айди и vec2 направления (В x и y). Линейный градиент это градиент, который
    /// направлен в одном конкретном направлении и цвет плавно меняется по этому
    /// направлению
    pub fn linear_gradient(&mut self, id: ObjectId, direction: Vec2) {
        self.renderer.config_gradient_data(id, [direction.x, direction.y, 0.0, 0.0]);
    }

    /// Эта функция устаналивает радиальный градиент объекту. Принимает айди объекта,
    /// центр самого градиента (vec2 из glam) и радиусы (Внутри и снаружи). Тоже vec2
    /// Радиальный градиент это градиент который выглядит как окружность внутри которой
    /// и происходит плавная смена цвета (Чем ближе к центру окружности)
    pub fn radial_gradient(&mut self, id: ObjectId, center: Vec2, radius: Vec2) {
        self.renderer.config_gradient_data(id, [center.x, center.y, radius.x, radius.y]);
    }

    /// Эта функция принимает айди объекта и удаляет градиент у него
    /// Работает и для линейного и для радиального
    pub fn reset_gradient(&mut self, id: ObjectId) {
        self.renderer.config_gradient_data(id, [0.0, 0.0, -1.0, 0.0]);
    }

    /// Функция для конфигурации скругления у прямоугольника.
    ///  - [!] Не работает для каких-либо объектов кроме прямоугольника.
    ///
    /// Принимает ID прямоугольника и Vec4 из GLAM для описания
    /// скругления каждого угла.
    ///    - [*] Скругление рисуется на GPU поэтому
    ///        не стоит переживать насчёт производительности от 
    ///        его использования.
    ///
    /// Описание radii (По часовой стрелке):
    ///     1 параметр - Верхний левый угол
    ///     2 параметр - Верхний праый угол
    ///     3 параметр - Нижний правый угол
    ///     4 параметр - Нижний левый угол
    ///
    ///    - [*] Про оптимизацию скругления - По факту скругление углов
    ///        ялвется чисто визуальным. У любого прямоугольника всегда
    ///        4 вершины и 6 индексов, но шейдер через алгоритм SDF
    ///        отсекает часть пикселей создавая скругление. Это очень
    ///        быстрый подход по сравнению со SKIA
    ///
    /// - [?] Для создания идеального круга создайте квадрат
    ///      (ширина и высота должна быть одинаковой) и установите
    ///      скругление углов на половину ширины/высоты.
    pub fn set_rounded(&mut self, id: ObjectId, radii: Vec4) {
        self.renderer.set_rounded(id, radii);
    }
 
    /// Функция определения Z индекса объекта. Обратите внимание,
    /// z индекс никак не вляяет на размер или координаты объекта.
    /// Он нужен чтобы отсортировать объекты и определить какие
    /// объекты будут перекрывать другие.
    ///     [*] Пример:
    ///         Объект A: Z индекс = 0.1
    ///         Объект B: Z индекс = 0.2
    ///     Объект B будет перекрывать объект A
    /// Принимает Id объекта и z индекс (флоат, может быть отрицательным
    /// Важно, z иднекс должен быть от 0 до 1. Нельзя использовать числа
    /// которые больше 1.0
    pub fn set_z_index(&mut self, id: ObjectId, z: f32) {
        self.renderer.set_z_index(id, z);
    }

    /// Эта функция устаналивает текстуру объекту. Сюда нужно передать айди объекта
    /// и айди текстуры. Айди текстуры млжно получить через mw.load_texture
    pub fn set_texture(&mut self, id: ObjectId, texture_id: u32) {
        self.renderer.state.store.config_texture(id, texture_id);
    }

    /// Эта функция устанавливает UV координаты для текстуры на объекте.
    /// Принимает айди объекта и массив из 4 флоатом (x, y, ширина, высота)
    pub fn set_uv(&mut self, id: ObjectId, uv: [f32; 4]) {
        self.renderer.state.store.config_uv(id, uv);
    }

    /// Эта функция устаналивает эффекты для объекта. Работает идеально только
    /// с прямоугольниками. Принимает айди объекта, ширину обводки и настройку
    /// для размытия углов (box_shadow Так как используется технология как в CSS)
    /// Цвет обводки объекта указывается в color2, обводка у которой есть градиент
    /// не поддерживается. Box_shadow не создаёт тень под объектом, а размывает границы.
    /// box_shadow не может заменить тени в Material design 3 либо в других дизайн
    /// системах где используется блюр по Гауссу, для реализации таких теней
    /// нужно создать рендер контейнер, сделать снапшот и применить блюр к текстуре
    /// два раза (горизонтально и вертикально) используя функцию mw.blur_texture(...)
    pub fn set_effect(&mut self, id: ObjectId, border_width: f32, box_shadow: f32) {
        self.renderer.set_effect(id, [border_width, box_shadow]);
    }

    /// Эта функция меняет уже существующий текст, принимает айди объекта (текста)
    /// у которого нужно изменить контент и новый контент
    pub fn set_text(&mut self, id: ObjectId, content: &str) {
        self.renderer.state.store.set_text(id, content.to_string());
    }

    /// Эта функция меняет размер шрифта у текста. Принимает айди текста и новый
    /// размер шрифта в формате f32
    pub fn set_font_size(&mut self, id: ObjectId, size: f32) {
        self.renderer.state.store.set_font_size(id, size);
    }
    
    /// Эта функция меняет границы текста. Не путать с set_font_size,
    /// она меняет размер шрифта, а эта функция меняет размер границ текста
    /// (как и было указанно ранее). Границы текста необходимы для переноса текста
    /// принимает айди, новую шириную и новую высоту
    pub fn set_text_size(&mut self, id: ObjectId, w: f32, h: f32) {
        self.renderer.state.store.set_text_bounds(id, w, h);
    }

    /// Эта функция нужна для выравнивания текста. Принимает его айди и
    /// направление для выравнивания. В enum TextAlign есть направления:
    /// 1. Left, выравнивания по левой стороне
    /// 2. Center, выравнивание по центру
    /// 3. Right, выравнивание по правой стороне
    /// 4. Justified, текст прижат к сторонам своих границ (они меняются через set_text_size) 
    pub fn set_text_align(&mut self, id: ObjectId, align: TextAlign) {
        let val = match align {
            TextAlign::Left => 0,
            TextAlign::Center => 1,
            TextAlign::Right => 2,
            TextAlign::Justified => 3,
        };
        self.renderer.state.store.set_text_align(id, val);
    }
    
    /// Эта функция нужна для получения размеров текста. Принимает контент строкой, шрифт
    /// (FontAsset, его можно получить через функцию load_font и load_font_from_bytes)
    /// размер шрифта и максимальную ширину. На выходе идёт Vec2 из крейта glam который
    /// содержит ширину и высоту текста по указанным параметрам
    pub fn measure_text(&mut self, text: &str, font: FontAsset, size: f32, max_width: f32) -> Vec2 {
        let (w, h) = self.renderer.text_engine.measure_text(
            text, 
            crate::textware::FontId(font.0), 
            size, 
            max_width
        );
        Vec2::new(w, h)
    }

    /// Эта функция делает объект с переданным ID мёртвым. Он сохраняет в ObjectStore,
    /// но перестаёт отрисовываться. Потом при создании другого объекта он занимает
    /// айди любого мёртвого объекта, если мёртвого объекта нет - создаёт новый id
    /// для себя
    pub fn remove(&mut self, id: ObjectId) {
        self.renderer.state.store.remove(id);
    }

    /// [WAIT DOC]
    pub fn remove_all(&mut self) {
        for id in 0..self.renderer.state.store.alive.len() {
            self.renderer.state.store.remove(ObjectId(id));
        }
    }
}
