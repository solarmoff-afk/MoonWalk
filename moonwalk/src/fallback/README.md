# Fallback для устройств с 32 битным лимитом
ObjectInstance в MoonWalk выглядит так:

```rust
pub struct ObjectInstance {
    pub pos_size:       [f32; 4],
    pub uv:             [u16; 4],
    pub radii:          [u16; 4],
    pub gradient_data:  [i16; 4],
    pub extra:          [f32; 2],
    pub color2:         u32,
    pub color:          u32,
    pub type_id:        u32,
    pub _pad:           u32,
}
```

Все поля занимают 64 байта (Если учитывать padding), но на разных устройствах могут быть разные лимиты. Может быть ошибка валидации если размер структуры не укладывается в лимиты драйвера (Например, на ноутбуке где проводилось тестирование лимит был ~86 байт)

# Решение
Решением явлется создание fallback пайплайна (конвейера) где вместо одной структуры используются две структуры по 32 байта каждая. Это добавляет нагрузку на CPU что приводит к снижению производительности, но позволяет запуститься движку на видеочипах которые не поддерживают 64 битные вершинные данные

# Проверки
Сейчас существуют 2 проверки которые позволяют определить нужно ли включать fallback пайплайн

## max_vertex_buffer_array_stride
Получение лимитов прямо из Device, однако этот способ оказался не самым надёжным. Он возвращает 2048 на ноутбуке где проводились тесты, хотя по факту на этом же ноутбуке ошибку валидации вызывает уже ~86+ байт. Эта проверка остаётся на всякий случай и помечена как [MAYBE], возможно её удаление в будущем

## Тестовый пайплайн
Более правильная проверка с созданием тестового пайлпайна с 64 битными вершинными данными. Если при его создании паника, то нужно включить fallback пайплайн

Используется следующий шейдер который можно найти в `moonwalk/src/shaders/empty.wgsl`:
```rust
@vertex
fn vs_main(@location(0) pos: vec4<f32>) -> @builtin(position) vec4<f32> {
    return pos;
}

@fragment
fn fs_main() -> @location(0) vec4<f32> {
    return vec4<f32>(0.0, 1.0, 0.0, 1.0);
}
```