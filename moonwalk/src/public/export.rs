// Часть проекта MoonWalk с открытым исходным кодом.
// Лицензия EPL 2.0, подробнее в файле LICENSE. Copyright (c) 2025 MoonWalk

use glam::{Vec4, Vec2};
use raw_window_handle::{HasWindowHandle, HasDisplayHandle};

use crate::{MoonWalk, MoonWalkError};
use crate::RenderContainer;

impl MoonWalk {
    /// Функция чтобы установить размер viewport'а (Область, куда идёт рисование)
    /// Если пользователь вашего приложения изменит размер окна (Через оконный менеджер) 
    /// то область рисования не уменьшится и не увеличиться.
    /// Решение: слушать событие изменения размеров окна и вызывать mw.set_viewport
    /// передавая туда новую ширину и высоту окна.
    pub fn set_viewport(&mut self, width: u32, height: u32) {
        self.renderer.resize(width, height);
    }

    /// Scale Factor нужно взять у winit либо другой библиотеки
    /// он необходим чтобы преобразовать логические размеры окна
    /// в физические (Иначе полноэкранного режима не будет на телефонах)
    pub fn set_scale_factor(&mut self, scale: f32) {
        self.renderer.set_scale_factor(scale);
    }

    /// Функция для рендеринга всех элементов которые накопил движок.
    /// Вызывать нужно КАЖДЫЙ КАДР, но не делать этого в бесконечном
    /// цикле (While/loop). Вместо этого лучше использовать встроенное
    /// событие в библиотеку для работы с окнами. Пример для winit:
    /// WindowEvent::RedrawRequested => { ... }
    /// Первый аргумент это структура Vec4 из крейта GLAM, сюда нужно
    /// передать цвет которым будет заливаться экран.
    pub fn render_frame(&mut self, clear_color: Vec4) -> Result<(), MoonWalkError> {
        self.renderer.render(clear_color)
    }

    /// Этот метод позволяет включить или выключить вертикальную синхронизацию
    pub fn set_vsync(&mut self, vsync: bool) {
        self.renderer.set_vsync(vsync);
    }

    /// Эта функция пересоздаёт холст для рендеринга. На android
    /// при сворачивании приложение старый холст удаляется поэтому
    /// нам нужен новый
    pub fn recreate_surface(&mut self, window: &(impl HasWindowHandle + HasDisplayHandle), width: u32, height: u32) {
        self.renderer.recreate_surface(window, width, height);
    }

    /// Снапшот (скриншот) это запекание конкретной области на экране либо в рендер
    /// контейнере в указанных координатах (pos, Vec2 из glam) и с указанным размером
    /// (size, Vec2 из glam). На выходе у функции обычное айди текстуры которое
    /// можно использовать
    pub fn snapshot(&mut self, pos: Vec2, size: Vec2) -> u32 {
        self.renderer.request_snapshot(
            pos.x as u32, 
            pos.y as u32, 
            size.x as u32, 
            size.y as u32,
        )
    }

    /// Эта функция создаёт снапшот не в новой текстуре, а в уже существующей.
    /// Нужно только передать её айди 3 аргументом. Первый и второй аргумент
    /// не отличается от snapshot, также pos (Vec2 из glam) и size (Vec2 из glam)
    /// чтобы указать координаты области и ширину/высоту области для снапшота.
    /// Ничего не возвращает, только обновляет
    pub fn update_snapshot(&mut self, pos: Vec2, size: Vec2, id: u32) {
        self.renderer.update_snapshot(
            pos.x as u32, 
            pos.y as u32, 
            size.x as u32, 
            size.y as u32,
            id,
        );
    }

    /// Рендер контейнер (Либо просто контейнер) это отдельный невидимый рендерер 
    /// (он не отправляет данные куда-либо) в котором можно создавать отдельные 
    /// от основного объекты (со своим айди) и единственный способ получить
    /// изображение из него, это функция .snapshot() внутри которая позволяет
    /// превратить в текстуру участок этого контейнера, указав x/y этого участка
    /// и ширину/высоту участка. После создания контейнера можно использовать почти
    /// все API функции который представлены здесь для создания, изменения и удаления
    /// объектов в контейнере.
    ///  [!] Функций для пересоздания поверхности (surface), создания контейнера
    ///      и так далее нет. Только создание (new_*), изменение (set_*) и удаление
    ///      (remove)
    /// После создания контейнера получается экземпляр структуры RenderContainer.
    /// Чтобы делать снапшоты внутри него нужно в каждый кадр вызывать container.draw()
    ///  в функцию draw нужно передать экземпляр структуры MoonWalk и цвет заливки.
    /// Прозрачный цвет принимается (Vec4::ZERO), если его указать то у текстуры
    /// не будет фона (Она будет прозрачная). Пример:
    ///  container.draw(mw, Some(Vec4::ZERO));
    /// Только после того как была вызвана функция .draw можно делать снапшот, так
    /// как до этого момента данные ещё не готовы
    pub fn new_render_container(&self, width: u32, height: u32) -> RenderContainer {
        RenderContainer::new(&self.renderer.context, width, height)
    }
}
